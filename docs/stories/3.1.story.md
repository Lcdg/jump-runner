# Story 3.1: Game State Machine

## Status

Done

## Story

**As a** developer,
**I want** a clean state machine managing game states,
**so that** transitions between Attract/Playing/GameOver are predictable and bug-free.

## Acceptance Criteria

1. Trois états définis : `AttractMode`, `Playing`, `GameOver`
2. Transitions claires : Attract → Playing (on Space), Playing → GameOver (on collision), GameOver → Attract (on Space)
3. Chaque état a ses propres comportements (update, render, handleInput)
4. État initial = AttractMode au lancement du jeu
5. Impossible de transitionner vers un état invalide
6. Tests unitaires pour chaque transition et les cas invalides
7. Architecture : pattern State ou simple enum + switch (au choix du dev)

## Tasks / Subtasks

- [x] **Task 1: Définir les types et l'enum GameState** (AC: 1, 7)
  - [x] Créer type `GameStateType = 'attract' | 'playing' | 'gameOver'` (déjà dans types.ts)
  - [x] Vérifier que le type existe et est correct

- [x] **Task 2: Créer le GameStateManager** (AC: 1, 2, 4, 5)
  - [x] Créer `src/core/GameStateManager.ts`
  - [x] Propriété `currentState: GameStateType`
  - [x] État initial = 'attract'
  - [x] Méthode `transition(to: GameStateType): boolean`
  - [x] Valider les transitions (attract→playing, playing→gameOver, gameOver→attract)
  - [x] Rejeter les transitions invalides (retourner false)

- [x] **Task 3: Définir les callbacks par état** (AC: 3)
  - [x] Interface `StateCallbacks { onEnter?: () => void, onExit?: () => void }`
  - [x] Permettre d'enregistrer des callbacks par état
  - [x] Appeler onExit de l'ancien état et onEnter du nouveau lors des transitions

- [x] **Task 4: Intégrer dans Game.ts** (AC: 2, 3, 4)
  - [x] Instancier GameStateManager dans constructor
  - [x] Modifier handleInput() pour gérer transitions (Space en attract/gameOver)
  - [x] Connecter collision callback pour transition playing→gameOver
  - [x] Modifier update() pour vérifier l'état avant d'updater le player
  - [x] Modifier render() pour afficher différemment selon l'état

- [x] **Task 5: Implémenter comportements par état** (AC: 3)
  - [x] **Attract**: décor défile, obstacles spawn, player visible mais pas contrôlable
  - [x] **Playing**: gameplay normal (player contrôlable, collisions actives)
  - [x] **GameOver**: décor défile, player invisible, obstacles défilent mais ne spawn plus

- [x] **Task 6: Écrire tests unitaires GameStateManager** (AC: 5, 6)
  - [x] Test: état initial = 'attract'
  - [x] Test: transition attract → playing (valid)
  - [x] Test: transition playing → gameOver (valid)
  - [x] Test: transition gameOver → attract (valid)
  - [x] Test: transition attract → gameOver (invalid)
  - [x] Test: transition playing → attract (invalid)
  - [x] Test: transition gameOver → playing (invalid)
  - [x] Test: callbacks onEnter/onExit appelés correctement

- [x] **Task 7: Écrire tests intégration Game** (AC: 2, 3)
  - [x] Test: Space en attract → passe en playing
  - [x] Test: collision en playing → passe en gameOver
  - [x] Test: Space en gameOver → passe en attract

- [x] **Task 8: Validation finale**
  - [x] `npm run lint` passe
  - [x] `npm run test:run` passe (154 tests)
  - [x] `npm run build` passe
  - [x] Test manuel: vérifier les transitions visuellement

## Dev Notes

### Previous Story Context
[Source: Story 2.2, Story 2.3]

**Code existant pertinent:**

1. **types.ts** - GameStateType déjà défini:
```typescript
export type GameStateType = 'attract' | 'playing' | 'gameOver';
```

2. **Game.ts** - Collision callback disponible:
```typescript
setOnCollision(callback: CollisionCallback | null): void
```

3. **InputManager.ts** - handleInput reçoit les actions:
```typescript
type InputAction = { type: 'jump_start' } | { type: 'jump_end' } | { type: 'start_game' };
```

### Architecture Technique

**Pattern recommandé**: Simple enum + switch (léger et suffisant pour 3 états)

```typescript
export class GameStateManager {
  private currentState: GameStateType = 'attract';

  private readonly validTransitions: Map<GameStateType, GameStateType[]> = new Map([
    ['attract', ['playing']],
    ['playing', ['gameOver']],
    ['gameOver', ['attract']],
  ]);

  transition(to: GameStateType): boolean {
    const allowed = this.validTransitions.get(this.currentState);
    if (!allowed?.includes(to)) return false;

    this.currentState = to;
    return true;
  }

  getState(): GameStateType {
    return this.currentState;
  }
}
```

### File Locations

| Nouveau fichier | Location |
|-----------------|----------|
| GameStateManager | `src/core/GameStateManager.ts` |
| Tests unitaires | `tests/unit/core/GameStateManager.test.ts` |

| Fichier à modifier | Modifications |
|--------------------|---------------|
| `src/core/Game.ts` | Intégrer GameStateManager, modifier update/render/handleInput |

### Comportements par état

| État | Player | Obstacles | Collisions | Input |
|------|--------|-----------|------------|-------|
| attract | Visible, statique | Spawn + défilent | Ignorées | Space → playing |
| playing | Contrôlable | Spawn + défilent | Actives | Jump controls |
| gameOver | Invisible | Défilent (pas de spawn) | Ignorées | Space → attract |

## Testing

| Type | Framework | Location |
|------|-----------|----------|
| Unit | Vitest | `tests/unit/core/GameStateManager.test.ts` |
| Integration | Vitest | `tests/unit/core/Game.state.test.ts` |

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-18 | 1.0 | Story créée | Dev Agent (James) |
| 2026-01-18 | 1.1 | Implémentation complète | Dev Agent (James) |

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
N/A

### Completion Notes List
- GameStateManager créé avec pattern simple (Map de transitions valides)
- Callbacks onEnter/onExit supportés pour chaque état
- Game.ts intégré avec logique d'état dans handleInput, update, render
- handleInput: Space en attract/gameOver déclenche transition, en playing déclenche jump
- update: logique conditionnelle par état (attract: spawn+move, playing: gameplay complet, gameOver: move seulement)
- render: player invisible en gameOver
- checkCollisions: déclenche transition vers gameOver automatiquement
- resetGameplay: réinitialise gameTime, obstacles, player lors de transitions vers playing/attract
- 18 tests unitaires GameStateManager (transitions, callbacks, reset)
- 13 tests intégration Game.state (cycle complet, comportements par état)
- Total: 154 tests passent

### File List
**Created:**
- `src/core/GameStateManager.ts` - Machine d'état avec transitions validées
- `tests/unit/core/GameStateManager.test.ts` - 18 tests
- `tests/unit/core/Game.state.test.ts` - 13 tests

**Modified:**
- `src/core/Game.ts` - Intégration stateManager, handleInput, update, render conditionnels

---

## QA Results
*(À compléter par le QA Agent)*
